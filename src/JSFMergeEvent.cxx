//*LastUpdate :  jsf-1-11  28-July-1999  By Akiya Miyamoto
//*-- Author  : Akiya Miyamoto  28-July-1999


///////////////////////////////////////////////////////////////////
//
// JSFMergeEvent
//
// Merge background event data to signal event.
// Purpose of this class is to merge events which are prepared in a root file
// by another run.  This can be used, for eacmple, to overly two-photon
// background events on another signal events.  Current version is designed so as
// to merge background events generated by PythiaGenerator class and JSFQuickSim class.
// When this object is included, event data of PythiaGenerator  and JSFQuickSim
// from a background data file are merged.
//
//
//(Parameters)
// Environment parameters and its default values are as follows.
//
// # A name of Background data file.
//  JSFMergeEvent.DataFile     simdst.dat  
// #
// # Luminosity per bunch train in unit of  1/nb (nano barn invers).  
// # Default value of 0.06 corresponds to collider luminosity 
// # of 9x10^{33} / cm^2 sec operated at RF pulse frequency of 150 Hz.
//  JSFMergeEvent.LumPerTrain  0.06        
// #
// # Seed of random number.  Since This class uses gRandom variable, it random
// # seed will be mixed up, if gRandom is used another place.
//  JSFMergeEvent.RandomSeed   1990729     
// #
//
// In JSFMergeEvent::Process(), the number background events are generated 
// according to the poisson distribution.  That number of events are picked up
// from the DataFile and their event data are appended into current event record.
//   
//$Id$
//
//////////////////////////////////////////////////////////////////

#include "JSFSteer.h"
#include "JSFMergeEvent.h"
#include <TMath.h>
#include <TRandom.h>
#include <TKey.h>

ClassImp(JSFMergeEvent)

//_____________________________________________________________________________
JSFMergeEvent::JSFMergeEvent(const Char_t *name, const Char_t *title,
			     const Char_t *opt)  : JSFModule(name,title, opt)
{
  // JSFMergeEvent constructor.
  //

  sscanf(gJSF->Env()->GetValue("JSFMergeEvent.DataFile","simdst.dat"),
	 "%s",fDataFileName);
  sscanf(gJSF->Env()->GetValue("JSFMergeEvent.LumPerTrain","0.06"),
    "%g",&fLumPerTrain);  // ( 1/nb unit. )
  fRandomSeed=gJSF->Env()->GetValue("JSFMergeEvent.RandomSeed",1990729),

  SetMakeBranch(kFALSE);

  fPythiaGenerator=NULL;
  fJSFQuickSim=NULL;
}

//_____________________________________________________________________________
JSFMergeEvent::~JSFMergeEvent()
{

  if( fFile ) { fFile->Close(); }
  if( fPythiaGenerator ) delete fPythiaGenerator;
  if( fJSFQuickSim ) delete fJSFQuickSim;

}


// ---------------------------------------------------------------
Bool_t JSFMergeEvent::Initialize()
{
  // Here we open a file and set branch from where merged event is read in.

  TDirectory *curdir=gDirectory;

  TFile *fFile=new TFile(fDataFileName,"READ");
 
  fPythiaGenerator=new PythiaGenerator("BKGPythiaGenerator",
		       "Background data of Pythia Generator","NO");
  fPythiaGenerator->SetFile(fFile);

  fJSFQuickSim    =new JSFQuickSim("BKGJSFQuickSim",
		       "Background data of JSFQuickSim","NO");
  fJSFQuickSim->SetFile(fFile);

  // Find the last run in the file.
  Int_t lrun=-1;

  fFile->cd("/conf");
    TList *dlist=gDirectory->GetListOfKeys();
    TListIter nkey(dlist);
    TKey  *key;
    Int_t irun;
    while ((key = (TKey*)nkey())) {
       Char_t tname[20];
       strncpy(tname,key->GetName(),9);
       if(strncmp(tname,"end",3)==0 ) {
	 sscanf(tname+3,"%d",&irun);
         if( irun > lrun ) { lrun = irun; }
       }
    }

    // Get end run information of previous run.
    Char_t kname[24];
    sprintf(kname,"/conf/end%5.5d",lrun);
    fFile->cd(kname);

    fPythiaGenerator->Read("PythiaGenerator");
    fJSFQuickSim->Read("JSFQuickSim");

    // Print information.
    printf("In JSFMergeEvent::Initialize()...\n");
    printf("   Cross section data of PythiaGenerator is obtained from a file %s\n",
	   fFile->GetName());
    fNumEvent=fPythiaGenerator->GetNGEN(0);
    printf("   Total number of events is %d \n",fNumEvent);
    Double_t xcros=fPythiaGenerator->GetXSEC(0)*1.0E6;
    printf("   Total cross section is %g (nb)\n",xcros);
    printf("   Luminosity per bunch train is %g (1/nb)\n",fLumPerTrain);
    fNumAverage=xcros*fLumPerTrain;
    printf("   Averaged number of background event is %g\n",fNumAverage);

    // Make tree to read background event.
    fFile->cd();
    fTree=(TTree*)fFile->Get("Event");

    fPythiaGenerator->SetBranch(fTree);
    fJSFQuickSim->SetBranch(fTree);

    // Set Seed of random number
    gRandom->SetSeed(fRandomSeed);

    curdir->cd();

  return kTRUE;
}


// ---------------------------------------------------------------
Bool_t JSFMergeEvent::BeginRun(Int_t nrun)
{
  Bool_t rc=kTRUE;
  return rc;
}

// ---------------------------------------------------------------
Bool_t JSFMergeEvent::EndRun()
{
  return kTRUE;
}


// ---------------------------------------------------------------
Bool_t JSFMergeEvent::Process(Int_t nev)
{
//

  Int_t nbkg=gRandom->Poisson(fNumAverage);

  printf(" JSFMergeEvent::Process was called. .. nbkg=%d\n",nbkg);

  if( nbkg <= 0 ) return kTRUE;
  
  JSFQuickSim  *qsim=(JSFQuickSim*)gJSF->FindModule("JSFQuickSim","quiet");
  JSFGenerator *gen=(JSFGenerator*)gJSF->FindModule("JSFGenerator","quiet");

  for(Int_t i=0;i<nbkg;i++){
    Int_t iev=(Int_t)(fNumEvent*gRandom->Rndm());
    fTree->GetEvent(iev);

    Int_t naddgen=0;
    if( gen != 0 ) {
      JSFGeneratorBuf *buf=(JSFGeneratorBuf*)gen->EventBuf();
      JSFGeneratorBuf *src=(JSFGeneratorBuf*)(fPythiaGenerator->EventBuf());
      naddgen=src->GetNparticles();
      buf->Append(src);
      printf(" Add naddgen=%d\n",naddgen);
    }

    if( qsim != 0 ) {
      JSFQuickSimBuf *sbuf=(JSFQuickSimBuf*)qsim->EventBuf();
      sbuf->Append((JSFQuickSimBuf*)(fJSFQuickSim->EventBuf()), naddgen);

      printf(" Quick Sim data is appended.\n");
    }

  }

  return kTRUE;
}





